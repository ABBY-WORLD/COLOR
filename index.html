<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Realistic RYB Paint Mixer (Simplified HSL)</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; cursor: crosshair; }
    </style>
</head>
<body>
<canvas id="paintCanvas"></canvas>
<script>
const canvas = document.getElementById('paintCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

/***************************************************************
 * 1) Färgdefinitioner och “piles”
 ***************************************************************/
const colors = {
    red:    [255,   0,   0],
    yellow: [255, 255,   0],
    blue:   [  0,   0, 255],
    white:  [255, 255, 255]
};

let currentMix = [];  // Vilka färger du har “laddat” i penseln
let painting   = false;

const piles = [
    { x:  50, y: 50, color: 'red'    },
    { x: 150, y: 50, color: 'yellow' },
    { x: 250, y: 50, color: 'blue'   },
    { x: 350, y: 50, color: 'white'  }
];

/***************************************************************
 * 2) Rita cirklar för färgpölarna
 ***************************************************************/
function drawPiles() {
    piles.forEach(pile => {
        ctx.fillStyle = `rgb(${colors[pile.color].join(',')})`;
        ctx.beginPath();
        ctx.arc(pile.x, pile.y, 30, 0, Math.PI * 2);
        ctx.fill();
    });
}

// Bakgrundsfärg
ctx.fillStyle = "rgb(90,90,90)";
ctx.fillRect(0, 0, canvas.width, canvas.height);
drawPiles();

/***************************************************************
 * 3) Mus-händelser: välj färg eller måla
 ***************************************************************/
canvas.addEventListener('mousedown', e => {
    // Kolla om vi klickar på någon färgcirkel
    piles.forEach(pile => {
        const dx = e.clientX - pile.x;
        const dy = e.clientY - pile.y;
        // Om vi klickar i pölens radie, “ladda” färgen i penseln
        if (dx * dx + dy * dy <= 30 * 30) {
            currentMix.push(colors[pile.color]);
        }
    });
    painting = true;
});

canvas.addEventListener('mouseup', () => {
    painting = false;
});

canvas.addEventListener('mousemove', e => {
    if (!painting || currentMix.length === 0) return;

    // Hämta befintlig pixel på canvasen (basfärg)
    const pixel = ctx.getImageData(e.clientX, e.clientY, 1, 1).data;
    let existingRGB = [pixel[0], pixel[1], pixel[2]];

    // Blanda “befintlig färg” + penselns laddade färger
    let mixedColor = getMixedColor(existingRGB, currentMix);

    // Måla en halvt transparent cirkel med den nya färgen
    ctx.fillStyle = `rgba(${mixedColor.join(',')},0.8)`;
    ctx.beginPath();
    ctx.arc(e.clientX, e.clientY, 30, 0, Math.PI * 2);
    ctx.fill();
});

/***************************************************************
 * 4) Förenklad HSL-blandning för “rätt” grundnyanser
 *    (gul + blå => grön)
 ***************************************************************/

/**
 * getMixedColor(baseColor, mixArray)
 *  - baseColor: [r,g,b] från canvasen
 *  - mixArray:  array av [r,g,b] för penseln
 * Returnerar en blandad [r,g,b] i 0..255
 */
function getMixedColor(baseColor, mixArray) {
    // Samla alla färger i en array (canvasens pixel + penselns färger)
    const allColors = [ baseColor, ...mixArray ];

    // Konvertera var och en till HSL (i [0..1]-format),
    // summera hue, sat, light och ta medelvärde.
    let sumH = 0, sumS = 0, sumL = 0;
    for (let c of allColors) {
        let [h, s, l] = rgbToHsl(c[0]/255, c[1]/255, c[2]/255);
        sumH += h;
        sumS += s;
        sumL += l;
    }
    let n = allColors.length;
    let avgH = sumH / n;
    let avgS = sumS / n;
    let avgL = sumL / n;

    // Konvertera tillbaka till RGB i [0..1], sedan skala upp till 0..255
    let [r, g, b] = hslToRgb(avgH, avgS, avgL);
    return [ Math.round(r*255), Math.round(g*255), Math.round(b*255) ];
}

/***************************************************************
 * 5) Hjälpfunktioner: RGB ↔ HSL
 ***************************************************************/

/**
 * rgbToHsl(r, g, b)  (var och en i [0..1])
 * Returnerar [h, s, l] i [0..1].
 */
function rgbToHsl(r, g, b) {
    let max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;

    if (max === min) {
        // Gråskala
        h = 0;
        s = 0;
    } else {
        let d = max - min;
        s = (l > 0.5) ? d / (2 - max - min) : d / (max + min);

        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return [h, s, l];
}

/**
 * hslToRgb(h, s, l)  (var och en i [0..1])
 * Returnerar [r, g, b] i [0..1].
 */
function hslToRgb(h, s, l) {
    if (s === 0) {
        // Gråskala
        return [l, l, l];
    }
    function hue2rgb(p, q, t) {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1/6) return p + (q - p) * 6 * t;
        if (t < 1/2) return q;
        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
    }
    let q = (l < 0.5) ? (l * (1 + s)) : (l + s - l*s);
    let p = 2*l - q;
    let r = hue2rgb(p, q, h + 1/3);
    let g = hue2rgb(p, q, h);
    let b = hue2rgb(p, q, h - 1/3);
    return [r, g, b];
}

/***************************************************************
 * 6) Hantera fönsterstorlek
 ***************************************************************/
window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    ctx.fillStyle = "rgb(90,90,90)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    drawPiles();
});
</script>
</body>
</html>
